# Secure CI/CD Pipeline (Jenkins + ECR + ECS)

[![Jenkins](https://img.shields.io/badge/Jenkins-LTS-red)](https://www.jenkins.io/)
[![Docker](https://img.shields.io/badge/Docker-20.10+-blue)](https://www.docker.com/)
[![Node.js](https://img.shields.io/badge/Node.js-18+-green)](https://nodejs.org/)
[![AWS](https://img.shields.io/badge/AWS-ECR%20%2B%20ECS-orange)](https://aws.amazon.com/)

This project implements a hardened CI/CD pipeline for a Node.js containerized app with end-to-end security gates and deployment to Amazon ECS.

## Overview

The pipeline performs:

- Build and unit test
- SAST (SonarQube + Quality Gate)
- SCA (OWASP Dependency-Check)
- Secret scan (Gitleaks)
- Image scan (Trivy)
- SBOM generation (Syft CycloneDX)
- Policy gate: fail on any `CRITICAL`/`HIGH` vulnerability or any secret finding
- Push versioned images to Amazon ECR
- Render + register ECS task definition revision
- Update ECS service with rolling deployment
- Archive reports and deployment evidence

## How Each Stage Is Used In This Project

- **Build and unit test**: `Jenkinsfile` runs `npm ci` and `npm test -- --coverage` to validate code before any image push or deployment.
- **SAST (SonarQube + Quality Gate)**: `Jenkinsfile` runs `sonar-scanner` and then `waitForQualityGate abortPipeline: true` to stop the pipeline if quality/security thresholds fail.
- **SCA (OWASP Dependency-Check)**: `Jenkinsfile` runs `owasp/dependency-check` in Docker and writes JSON/HTML reports to `reports/sca/`.
- **Secret scan (Gitleaks)**: `Jenkinsfile` runs `${GITLEAKS_IMAGE}` (default/fallback `ghcr.io/gitleaks/gitleaks:latest`) and outputs findings to `reports/secret/gitleaks-report.json`.
- **Image scan (Trivy)**: After building the app image, `Jenkinsfile` runs Trivy and writes `reports/image/trivy-image.json`.
- **SBOM generation (Syft CycloneDX)**: `Jenkinsfile` runs Syft and writes CycloneDX SBOM to `reports/sbom/sbom-cyclonedx.json`.
- **Policy gate (block on CRITICAL/HIGH or secrets)**: `scripts/security-gate.js` parses SCA, Trivy, and Gitleaks reports and exits non-zero if blocked findings exist; `Jenkinsfile` fails at `Security Gate`.
- **Push versioned images to Amazon ECR**: `Jenkinsfile` tags and pushes `build-*`, `sha-*`, and `latest` to ECR using AWS CLI login.
- **Render + register ECS task definition revision**: `scripts/render-ecs-taskdef.sh` fills placeholders in `ecs/taskdef.template.json`; `Jenkinsfile` registers the rendered JSON as a new ECS revision.
- **Update ECS service with rolling deployment**: `Jenkinsfile` runs `aws ecs update-service --force-new-deployment` and waits for service stability.
- **Archive reports and deployment evidence**: `Jenkinsfile` archives `reports/**/*` and includes deployment outputs such as `reports/deploy/ecs-update-service.json` and `reports/deploy/ecs-service-status.json`.

## Repository Deliverables

- `Jenkinsfile` - Secure CI/CD workflow with quality/security gates and ECS deploy
- `ecs/taskdef.template.json` - ECS task definition template
- `ecs/taskdef.rendered.example.json` - Example rendered task definition revision JSON
- `ecs/ecr-lifecycle-policy.json` - ECR lifecycle policy for image cleanup
- `scripts/security-gate.js` - Enforces vulnerability/secret blocking rules
- `reports/` - Security and deployment artifacts (generated by pipeline)
- `evidence/README.md` - Evidence checklist for submission
- `docs/SECURE-CICD-ECS.md` - Detailed setup and validation guide

## Pipeline Stages

1. Checkout
2. Validate required inputs
3. Build metadata and image tags
4. Install dependencies
5. Unit tests
6. SAST (SonarQube)
7. SAST quality gate wait
8. Secret scan (Gitleaks)
9. SCA (Dependency-Check)
10. SBOM generation (Syft)
11. Docker image build
12. Image scan (Trivy)
13. Security gate enforcement
14. ECR login and push (`build-*`, `sha-*`, `latest`)
15. Apply ECR lifecycle policy
16. Render and register ECS task definition
17. Update ECS service and wait for stability
18. Cleanup older ECS task definition revisions

## Required Jenkins Parameters

Configured in `Jenkinsfile`:

- `AWS_REGION`
- `AWS_ACCOUNT_ID`
- `ECR_REPOSITORY`
- `ECS_CLUSTER`
- `ECS_SERVICE`
- `ECS_TASK_FAMILY`
- `ECS_EXECUTION_ROLE_ARN`
- `ECS_TASK_ROLE_ARN`
- `CLOUDWATCH_LOG_GROUP`
- `ENABLE_SONARQUBE`
- `SONARQUBE_SERVER`
- `GITLEAKS_IMAGE`
- `DEPLOYMENT_STRATEGY` (rolling)
- `APPLY_ECR_LIFECYCLE_POLICY`
- `KEEP_ECS_REVISIONS`

## Prerequisites

- Jenkins controller/agent with:
  - Docker CLI + daemon access
  - AWS CLI
  - Node.js 18+
- SonarQube server configured in Jenkins as `sonarqube`
- AWS credentials on Jenkins with permissions for:
  - ECR (create repo, login, push, lifecycle policy)
  - ECS (register task definition, update service, describe/wait)
  - IAM pass-role where required for task/execution roles

## Reports and Evidence Paths

Artifacts generated during pipeline run:

- `reports/sca/dependency-check-report.json`
- `reports/sca/dependency-check-report.html`
- `reports/image/trivy-image.json`
- `reports/secret/gitleaks-report.json`
- `reports/sbom/sbom-cyclonedx.json`
- `reports/deploy/taskdef.rendered.json`
- `reports/deploy/taskdef-arn.txt`
- `reports/deploy/ecs-update-service.json`
- `reports/deploy/ecs-service-status.json`

## Validation Workflow (Fail then Pass)

Inject known vulnerable dependency (expected: gate fails before deploy):

```bash
scripts/inject-vulnerable-dependency.sh
```

Remove injected dependency (expected: gate passes and deploy runs):

```bash
scripts/remove-vulnerable-dependency.sh
```

## Local App Test

```bash
npm ci
npm test
npm start
curl http://localhost:5000/health
```

## Quick Start (If You Are Confused)

Use this section first if you want a simple "what do I run?" guide.

### What this project does

- It is a Node.js app (`app.js`) plus a Jenkins CI/CD pipeline (`Jenkinsfile`).
- **Local run**: run and test the app on your machine.
- **Pipeline run**: Jenkins runs tests and security scans, then deploys to ECS only if security gates pass.

### Run the app locally (step-by-step)

From repo root:

```bash
npm ci
npm test
npm start
```

Open a second terminal and verify:

```bash
curl http://localhost:5000/health
curl http://localhost:5000/api/info
```

If both commands return valid JSON/OK output, your app is running correctly.

### Same flow with Makefile

```bash
make install
make test
make run
```

### How Jenkins pipeline works (simple model)

When you push changes and trigger Jenkins:

1. Installs dependencies and runs tests.
2. Runs security checks (SAST, SCA, secret scan, image scan, SBOM).
3. Runs policy gate (`scripts/security-gate.js`).
4. If gate passes: pushes image to ECR and deploys to ECS.
5. Archives reports in `reports/`.

### Why vulnerable dependency scripts exist

These scripts are for demonstrating the security gate behavior:

```bash
# should make pipeline fail at security gate
scripts/inject-vulnerable-dependency.sh

# should allow pipeline to pass again after fix
scripts/remove-vulnerable-dependency.sh
```

### Suggested first learning flow

1. Run locally (`npm ci`, `npm test`, `npm start`).
2. Verify endpoints with `curl`.
3. Make a small change and commit.
4. Push and trigger Jenkins build.
5. Check whether build fails at security gate or passes to deployment.

## Command Reference

### 1. Setup

```bash
# from repository root
npm ci
```

### 2. Run the app locally

```bash
# start server (port 5000 by default)
npm start

# in another terminal: verify health
curl http://localhost:5000/health

# in another terminal: app info
curl http://localhost:5000/api/info
```

### 3. Run tests

```bash
# unit tests
npm test

# coverage
npm run test:coverage
```

### 4. Run with Docker

```bash
# build image
docker build -t cicd-node-app:local .

# run container
docker run --rm -p 5000:5000 --name cicd-node-app-local cicd-node-app:local

# verify from another terminal
curl http://localhost:5000/health

# stop container (if not using --rm)
docker stop cicd-node-app-local
```

### 5. Security gate validation commands

```bash
# inject vulnerable dependency (pipeline should fail security gate)
scripts/inject-vulnerable-dependency.sh

# remove injected vulnerable dependency (pipeline should pass after fix)
scripts/remove-vulnerable-dependency.sh
```

### 6. Utility commands

```bash
# lint (if needed during development)
npm run lint

# dev mode (auto-restart)
npm run dev
```

### 7. Jenkins pipeline run (high level)

```bash
# Jenkins executes the pipeline from Jenkinsfile.
# Trigger a new build from Jenkins UI after pushing your changes.
```

## Documentation

- `docs/SECURE-CICD-ECS.md`
- `RUNBOOK.md`
- `TROUBLESHOOTING.md`
- `evidence/README.md`

## Notes

- ECS task definition uses `awslogs` log driver for CloudWatch logs.
- Monitoring alarms from your Project-Monitoring stack should be pointed at ECS-relevant metrics/log groups.
- ECR lifecycle policy and ECS task revision cleanup are included to reduce artifact sprawl.
